<hr />
<h2
id="title-esp32-ota-esp_32_ota-mechanism-version-10-commit-51e257c695009957ec1183a0f769b73908d4013b-branch-dt-date-2025-11-15">title:
ESP32 OTA (ESP_32_OTA) Mechanism version: '1.0' commit:
'51e257c695009957ec1183a0f769b73908d4013b' branch: 'DT' date:
'2025-11-15'</h2>
<h1
id="esp32-ota-esp_32_ota-mechanism-â-comprehensive-documentation">ESP32
OTA (ESP_32_OTA) Mechanism â€” Comprehensive Documentation</h1>
<p>Version: 1.0</p>
<p>Repository:
<code>d:\LabExpert\LabExpert_Sensor_Communications</code></p>
<p>Build Metadata:</p>
<ul>
<li>Commit: <code>&lt;to-be-populated&gt;</code></li>
<li>Branch: <code>&lt;to-be-populated&gt;</code></li>
<li>Build date: <code>&lt;to-be-populated&gt;</code></li>
</ul>
<h2 id="overview">Overview</h2>
<ul>
<li>Purpose: Provide a robust OTA process for ESP32-based devices,
featuring a dedicated OTA bootloader (<code>ota_0</code>) and
application firmware (<code>ota_1</code>).</li>
<li>Components: ESP32 OTA bootloader (<code>ESP_32_OTA</code>), sensor
firmwares (<code>TOF_*</code>, <code>UltraSonic_*</code>,
<code>OSI_*</code>), backend service, browser client, WiFi network, MQTT
broker, UDP discovery.</li>
<li>High-level modes:
<ul>
<li>Bootloader mode (<code>ota_0</code>): Accepts firmware via HTTP
upload and a backend push API; performs partition erase and streaming
writes, then restarts.</li>
<li>Application mode (<code>ota_1</code>): Runs sensor/UI firmware; can
trigger rollback to bootloader upon sensor/EEPROM failure or manual
input.</li>
</ul></li>
</ul>
<h2 id="workflow-analysis">Workflow Analysis</h2>
<h3 id="initialization">Initialization</h3>
<ul>
<li>Partition status: Logs current partition at boot and treats
<code>ota_0</code> as OTA bootloader mode
(<code>ESP_32_OTA/src/main.cpp:391-399</code>).</li>
<li>Sensor detection: Reads EEPROM over I2C (<code>Wire</code>) with
retries; sets <code>sensorType</code> or marks <code>UNKNOWN</code> and
handles fallback (<code>ESP_32_OTA/src/main.cpp:94-156</code>).</li>
<li>WiFi setup: STA mode, DHCP, connect to
<code>ssid</code>/<code>password</code>, then start
<code>WebServer</code> and UDP discovery
(<code>ESP_32_OTA/src/main.cpp:454-483</code>).</li>
<li>Inactive partition erase: At startup, erases the non-running OTA
partition to ensure a clean target
(<code>ESP_32_OTA/src/main.cpp:66-92</code>, called at
<code>450-452</code>).</li>
<li>Route setup: Registers HTTP routes including OTA web upload and
backend push endpoints
(<code>ESP_32_OTA/src/main.cpp:196-339</code>).</li>
</ul>
<h3 id="firmware-download-sequence">Firmware Download Sequence</h3>
<ul>
<li>Web upload (multipart form):
<ul>
<li><code>POST /update</code> writes file chunks:
<code>Update.begin(UPDATE_SIZE_UNKNOWN)</code> â†’
<code>Update.write(upload.buf)</code> â†’ <code>Update.end(true)</code>,
then restart (<code>ESP_32_OTA/src/main.cpp:211-242</code>).</li>
</ul></li>
<li>Backend push API (JSON hex streaming):
<ul>
<li><code>POST /ota/begin { size }</code> initializes
<code>Update.begin(size)</code> and sets <code>otaInProgress</code>
(<code>ESP_32_OTA/src/main.cpp:265-287</code>).</li>
<li><code>POST /ota/write { offset, size, data(hex) }</code> decodes hex
â†’ bytes and calls <code>Update.write(bytes)</code> with strict size
checks (<code>ESP_32_OTA/src/main.cpp:288-321</code>).</li>
<li><code>POST /ota/end</code> finalizes with
<code>Update.end(true)</code> and restarts
(<code>ESP_32_OTA/src/main.cpp:322-339</code>).</li>
</ul></li>
<li>Sensor firmwares (<code>ESPAsyncWebServer</code>):
<ul>
<li><code>POST /update</code> handler streams
<code>Update.write(data)</code> and finalizes
<code>Update.end(true)</code> then restart
(<code>TOF_Firmware_bin_Generator/src/config_handler.cpp:212-241</code>).</li>
</ul></li>
</ul>
<h3 id="verification-steps">Verification Steps</h3>
<ul>
<li>Write verification:
<ul>
<li>Checks <code>Update.begin</code> and compares bytes written to
expected size; errors via <code>Update.printError(Serial)</code>.</li>
</ul></li>
<li>Completion status:
<ul>
<li>Uses <code>Update.end(true)</code> and
<code>Update.hasError()</code> to determine <code>OK</code> vs
<code>FAIL</code> (<code>ESP_32_OTA/src/main.cpp:213</code>,
<code>236-242</code>).</li>
</ul></li>
<li>Input validation for push API:
<ul>
<li>JSON parse checks with error codes; hex decoding validation; size
mismatch guards (<code>ESP_32_OTA/src/main.cpp:270-307</code>).</li>
</ul></li>
<li>Cryptographic verification:
<ul>
<li>Not implemented; no SHA256/CRC signature checks; relies on
<code>Update</code> success.</li>
</ul></li>
</ul>
<h3 id="update-procedure">Update Procedure</h3>
<ul>
<li>Target partition selection:
<ul>
<li>Bootloader reports running and next update partitions; streams to
<code>esp_ota_get_next_update_partition(NULL)</code>
(<code>ESP_32_OTA/src/main.cpp:217-221, 227-229</code>).</li>
</ul></li>
<li>Partition erase:
<ul>
<li>Erases inactive partition at boot for a clean slate
(<code>ESP_32_OTA/src/main.cpp:66-92</code>).</li>
</ul></li>
<li>Restart:
<ul>
<li>On success, calls <code>ESP.restart()</code> after brief delay
(<code>ESP_32_OTA/src/main.cpp:333-334</code>, <code>221</code>).</li>
</ul></li>
</ul>
<h3 id="rollback-mechanism">Rollback Mechanism</h3>
<ul>
<li>Manual rollback:
<ul>
<li>Application firmwares can disconnect MQTT/WiFi and set boot
partition to the opposite OTA slot via
<code>esp_ota_set_boot_partition</code>, then restart
(<code>OSI_Firmware_bin_Generator/src/main.cpp:205-271</code>).</li>
</ul></li>
<li>Sensor-triggered rollback:
<ul>
<li>On EEPROM/sensor failure, erase inactive partition and reboot to
bootloader (<code>ESP_32_OTA/src/main.cpp:510-519</code>).</li>
</ul></li>
<li>Automatic runtime rollback framework:
<ul>
<li>Not used (e.g., <code>esp_ota_mark_app_valid_cancel_rollback</code>
absent). Rollback is explicit/manual.</li>
</ul></li>
</ul>
<h2 id="visual-documentation">Visual Documentation</h2>
<h3 id="architecture-diagram">Architecture Diagram</h3>
<ul>
<li>See <code>architecture.drawio</code> and
<code>architecture.png</code> (to be generated). Components and
connections:
<ul>
<li>ESP32 OTA Bootloader (<code>ota_0</code>) â†” Browser (HTTP form
upload)</li>
<li>ESP32 OTA Bootloader â†” Backend (HTTP push API)</li>
<li>ESP32 OTA Bootloader â†” UDP discovery (ports 8888/8889)</li>
<li>Application firmware (<code>ota_1</code>) â†” MQTT broker
(status/control)</li>
<li>WiFi AP/Router between all networked components</li>
</ul></li>
</ul>
<h3 id="sequence-diagrams">Sequence Diagrams</h3>
<ul>
<li><code>sequence_web_upload.mmd</code>: Browser-based upload to
<code>/update</code> with streaming and restart.</li>
<li><code>sequence_backend_push.mmd</code>: Backend push flow with
begin/write/end and error cases.</li>
</ul>
<h3 id="flowchart">Flowchart</h3>
<ul>
<li><code>flowchart.mmd</code>: End-to-end OTA process with decision
points (WiFi, sensor presence, begin/write/end success, restart).</li>
</ul>
<h3 id="state-diagram">State Diagram</h3>
<ul>
<li><code>state_diagram.mmd</code>: Bootloader â†” Main firmware â†” OTA
In Progress â†” Error/Recovery states.</li>
</ul>
<h2 id="technical-specifications">Technical Specifications</h2>
<h3 id="communication-protocols">Communication Protocols</h3>
<ul>
<li>HTTP:
<ul>
<li>Bootloader: <code>WebServer</code> on port 80. Endpoints:
<code>/</code>, <code>/update</code>, <code>/info</code>,
<code>/ping</code>, <code>/id</code>, <code>/ota/begin</code>,
<code>/ota/write</code>, <code>/ota/end</code>
(<code>ESP_32_OTA/src/main.cpp:196-339</code>).</li>
<li>Sensor firmwares: <code>ESPAsyncWebServer</code> with
<code>POST /update</code>
(<code>TOF_Firmware_bin_Generator/src/config_handler.cpp:212-241</code>).</li>
</ul></li>
<li>UDP:
<ul>
<li>Discovery port <code>8888</code>, response <code>8889</code>
(<code>ESP_32_OTA/src/main.cpp:59-65, 341-389</code>,
<code>OSI_Firmware_bin_Generator/src/main.cpp:24-31</code>).</li>
</ul></li>
<li>MQTT:
<ul>
<li>Used in application firmwares for telemetry/control; not used for
OTA data transfer
(<code>OSI_Firmware_bin_Generator/src/main.cpp:88-91</code>).</li>
</ul></li>
</ul>
<h3 id="security-measures">Security Measures</h3>
<ul>
<li>Transport:
<ul>
<li>OTA occurs over HTTP without TLS; no
<code>esp_https_ota</code>/<code>WiFiClientSecure</code> in OTA
path.</li>
</ul></li>
<li>Access control:
<ul>
<li>OTA endpoints have no authentication; accessible on local
network.</li>
</ul></li>
<li>Integrity:
<ul>
<li>Relies on <code>Update</code> success and internal write checks; no
cryptographic signature or checksum verification.</li>
</ul></li>
<li>Recommendations:
<ul>
<li>Use HTTPS with certificate pinning for OTA push.</li>
<li>Add authentication (HMAC tokens or mutual TLS).</li>
<li>Implement firmware SHA256 verification and optional signing
(ECDSA/RSA).</li>
<li>Rate-limit and CSRF-protect web upload.</li>
</ul></li>
</ul>
<h3 id="memory-requirements-and-constraints">Memory Requirements and
Constraints</h3>
<ul>
<li>Partition layout (typical 4MB flash, per
<code>ESPAsyncWebServer</code> reference table):
<ul>
<li><code>ota_0</code> app: ~1856 KB; <code>ota_1</code> app: ~1856 KB;
NVS/otadata/spiffs/coredump reserved
(<code>TOF_Firmware_bin_Generator/.pio/libdeps/esp32dev/ESPAsyncWebServer/partitions-4MB.csv:1-7</code>).</li>
</ul></li>
<li>OTA write strategy:
<ul>
<li>Streaming writes consume minimal RAM; buffers are per-chunk from
HTTP upload or push.</li>
</ul></li>
<li>Constraints:
<ul>
<li>Firmware binary must fit available app partition size.</li>
<li>Erase of inactive partition ensures maximal contiguous space.</li>
</ul></li>
</ul>
<h3 id="performance-characteristics">Performance Characteristics</h3>
<ul>
<li>LED intervals: WiFi/Sensor LEDs toggle every 3s in bootloader
(<code>ESP_32_OTA/src/main.cpp:47-51, 159-175, 178-194</code>).</li>
<li>UDP discovery check: Every 1s in bootloader; every 5s in OSI
firmware (<code>ESP_32_OTA/src/main.cpp:63-65, 341-389</code>;
<code>OSI_Firmware_bin_Generator/src/main.cpp:29-31, 128-183</code>).</li>
<li>Sensor check interval: 2s
(<code>ESP_32_OTA/src/main.cpp:40-42, 501-521</code>).</li>
<li>WiFi reconnection: On loss, attempts reconnect with 5s delay
(<code>ESP_32_OTA/src/main.cpp:493-499</code>).</li>
<li>OTA throughput: Bound by HTTP chunk size and WiFi RSSI; typical
ESP32 SPI flash write speeds support multi-hundred KB/s in good
conditions.</li>
</ul>
<h2 id="api-reference-summary">API Reference Summary</h2>
<ul>
<li>Full details in <code>api_reference.md</code>. Key endpoints:
<ul>
<li>Web upload: <code>POST /update</code> (multipart form-data
<code>update</code>).</li>
<li>Backend push: <code>POST /ota/begin</code>,
<code>POST /ota/write</code>, <code>POST /ota/end</code>.</li>
<li>Informational: <code>GET /</code>, <code>GET /info</code>,
<code>GET /ping</code>, <code>GET /id</code>.</li>
</ul></li>
</ul>
<h2 id="troubleshooting">Troubleshooting</h2>
<ul>
<li>WiFi loss:
<ul>
<li>Device logs reconnection attempts; ensure SSID/password and AP
stability (<code>ESP_32_OTA/src/main.cpp:493-499</code>).</li>
</ul></li>
<li>EEPROM/sensor not detected:
<ul>
<li>Bootloader may restart or remain in OTA mode; reconnect sensor and
retry; check I2C wiring (<code>ESP_32_OTA/src/main.cpp:404-425</code>,
<code>510-519</code>).</li>
</ul></li>
<li>OTA write failures:
<ul>
<li>Inspect serial logs for <code>Update.printError</code>; verify chunk
sizes and JSON/hex validity for push API
(<code>ESP_32_OTA/src/main.cpp:270-307, 313-318</code>).</li>
</ul></li>
<li>Partition operations fail:
<ul>
<li>If <code>esp_ota_set_boot_partition</code> or
<code>esp_partition_erase_range</code> fails, device falls back to
restart; check partition table compatibility and flash health
(<code>ESP_32_OTA/src/main.cpp:77-86</code>;
<code>OSI_Firmware_bin_Generator/src/main.cpp:254-271</code>).</li>
</ul></li>
</ul>
<h2 id="version-control-information">Version Control Information</h2>
<ul>
<li><code>firmware_version</code> reported by bootloader in UDP
discovery: <code>OTA_BOOTLOADER</code>
(<code>ESP_32_OTA/src/main.cpp:371</code>).</li>
<li>OSI firmware UDP discovery reports version <code>1.0</code>
(<code>OSI_Firmware_bin_Generator/src/main.cpp:158-159</code>).</li>
<li>Include commit, branch, and build date in PDF header during
generation.</li>
</ul>
<h2 id="appendices">Appendices</h2>
<ul>
<li>File references used in this document follow
<code>file_path:line_number</code> format for traceability.</li>
</ul>
